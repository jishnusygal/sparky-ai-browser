// Sparky AI Browser - Enhanced Background Service Worker
// The \"Brain\" that coordinates the AI agent's actions with strict JSON schema enforcement

import { createSimplifiedDOM, delay } from './utils.js';\n\nclass SparkyAgent {\n    constructor() {\n        this.state = 'idle'; // idle, running, finished, paused\n        this.currentGoal = '';\n        this.apiKey = '';\n        this.actionHistory = [];\n        this.maxActions = 25; // Increased for more complex tasks\n        this.currentTabId = null;\n        this.retryCount = 0;\n        this.maxRetries = 3;\n        \n        // JSON Schema for strict validation\n        this.actionSchema = {\n            type: 'object',\n            properties: {\n                thought: { type: 'string', minLength: 5, maxLength: 200 },\n                command: { \n                    type: 'string', \n                    enum: ['CLICK', 'TYPE', 'SCROLL', 'WAIT', 'FINISH'] \n                },\n                targetId: { type: 'string', pattern: '^agent-id-\\\\d+$' },\n                text: { type: 'string', maxLength: 500 },\n                scrollDirection: { type: 'string', enum: ['UP', 'DOWN'] },\n                answer: { type: 'string', minLength: 1, maxLength: 1000 }\n            },\n            required: ['thought', 'command'],\n            additionalProperties: false\n        };\n        \n        this.setupMessageListeners();\n        this.setupActionListener();\n    }\n\n    setupMessageListeners() {\n        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n            this.handleMessage(message, sender, sendResponse);\n            return true; // Keep the message channel open for async responses\n        });\n    }\n\n    setupActionListener() {\n        chrome.action.onClicked.addListener(async (tab) => {\n            await chrome.sidePanel.open({ tabId: tab.id });\n        });\n    }\n\n    async handleMessage(message, sender, sendResponse) {\n        try {\n            switch (message.type) {\n                case 'START_TASK':\n                    await this.startTask(message.payload);\n                    break;\n                    \n                case 'DOM_OBSERVATION':\n                    await this.processDOMObservation(message.payload, sender.tab.id);\n                    break;\n                    \n                case 'ACTION_COMPLETED':\n                    await this.handleActionCompleted(message.payload);\n                    break;\n                    \n                case 'ACTION_ERROR':\n                    await this.handleActionError(message.payload);\n                    break;\n                    \n                case 'PAUSE_TASK':\n                    this.state = 'paused';\n                    await this.sendStatusUpdate('‚è∏Ô∏è Task paused by user', 'info');\n                    break;\n                    \n                case 'RESUME_TASK':\n                    if (this.state === 'paused') {\n                        this.state = 'running';\n                        await this.sendStatusUpdate('‚ñ∂Ô∏è Task resumed', 'info');\n                        await this.runAgenticLoop();\n                    }\n                    break;\n                    \n                default:\n                    console.log('Unknown message type:', message.type);\n            }\n        } catch (error) {\n            console.error('Error handling message:', error);\n            await this.sendStatusUpdate(`Critical error: ${error.message}`, 'error');\n            await this.sendError(error.message);\n        }\n    }\n\n    async startTask(payload) {\n        if (this.state === 'running') {\n            await this.sendStatusUpdate('Task already running. Please wait for completion.', 'error');\n            return;\n        }\n\n        // Reset state for new task\n        this.state = 'running';\n        this.currentGoal = payload.goal;\n        this.apiKey = payload.apiKey;\n        this.actionHistory = [];\n        this.retryCount = 0;\n        \n        // Validate API key format\n        if (!this.apiKey || this.apiKey.length < 10) {\n            await this.sendError('Invalid API key format');\n            return;\n        }\n        \n        // Get active tab\n        const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (!activeTab) {\n            await this.sendError('No active tab found');\n            return;\n        }\n        \n        this.currentTabId = activeTab.id;\n\n        await this.sendStatusUpdate('üöÄ Starting agentic browsing...', 'info');\n        await this.sendStatusUpdate(`üéØ Goal: ${this.currentGoal}`, 'info');\n        await this.sendStatusUpdate(`üìÑ Current page: ${activeTab.url}`, 'info');\n        \n        // Start the agentic loop\n        await this.runAgenticLoop();\n    }\n\n    async runAgenticLoop() {\n        try {\n            if (this.state !== 'running') {\n                return; // Task paused or stopped\n            }\n            \n            if (this.actionHistory.length >= this.maxActions) {\n                await this.finishTask('Maximum actions reached. Task may be too complex or require manual completion.');\n                return;\n            }\n\n            const actionCount = this.actionHistory.length + 1;\n            await this.sendStatusUpdate(`üîç Observing page (Step ${actionCount}/${this.maxActions})...`, 'info');\n            \n            // Step 1: Observe the current page\n            await this.injectContentScriptAndObserve();\n            \n            // The loop will continue when we receive the DOM observation\n            // We break here and let processDOMObservation continue the loop\n        } catch (error) {\n            console.error('Error in agentic loop:', error);\n            await this.handleLoopError(error);\n        }\n    }\n\n    async handleLoopError(error) {\n        this.retryCount++;\n        \n        if (this.retryCount < this.maxRetries) {\n            await this.sendStatusUpdate(`‚ö†Ô∏è Error occurred, retrying (${this.retryCount}/${this.maxRetries}): ${error.message}`, 'error');\n            await delay(2000);\n            await this.runAgenticLoop();\n        } else {\n            await this.sendError(`Max retries exceeded: ${error.message}`);\n        }\n    }\n\n    async injectContentScriptAndObserve() {\n        try {\n            // Inject content script with error handling\n            await chrome.scripting.executeScript({\n                target: { tabId: this.currentTabId },\n                files: ['content_script.js']\n            });\n\n            // Wait for script to initialize\n            await delay(800);\n\n            // Request observation with timeout\n            const observationPromise = chrome.tabs.sendMessage(this.currentTabId, {\n                type: 'OBSERVE'\n            });\n            \n            // Add timeout to prevent hanging\n            const timeoutPromise = new Promise((_, reject) => \n                setTimeout(() => reject(new Error('Observation timeout')), 10000)\n            );\n            \n            await Promise.race([observationPromise, timeoutPromise]);\n            \n        } catch (error) {\n            console.error('Error injecting content script:', error);\n            \n            if (error.message.includes('Cannot access')) {\n                await this.sendError('Cannot access this page. Try navigating to a different website.');\n            } else {\n                await this.sendError(`Failed to observe page: ${error.message}`);\n            }\n        }\n    }\n\n    async processDOMObservation(domData, tabId) {\n        try {\n            // Validate DOM data\n            if (!domData || !domData.elements) {\n                throw new Error('Invalid DOM data received');\n            }\n            \n            await this.sendStatusUpdate(`üìä Found ${domData.elements.length} interactive elements`, 'info');\n            await this.sendStatusUpdate('üß† AI is analyzing the page...', 'info');\n            \n            // Step 2: Think - Get decision from Gemini API with retries\n            const decision = await this.getAIDecisionWithRetry(domData);\n            \n            if (!decision) {\n                throw new Error('Failed to get valid AI decision after retries');\n            }\n\n            // Validate the decision against schema\n            const validationResult = this.validateDecision(decision);\n            if (!validationResult.valid) {\n                throw new Error(`Invalid AI decision: ${validationResult.errors.join(', ')}`);\n            }\n\n            await this.sendStatusUpdate(`üí≠ AI Decision: ${decision.thought}`, 'info');\n            \n            // Step 3: Act based on decision\n            if (decision.command === 'FINISH') {\n                await this.finishTask(decision.answer || 'Task completed successfully!');\n                return;\n            }\n            \n            // Validate command-specific requirements\n            if (!this.validateCommandRequirements(decision)) {\n                throw new Error('Decision missing required parameters for command');\n            }\n            \n            // Record the action\n            this.actionHistory.push({\n                action: decision,\n                timestamp: Date.now(),\n                url: domData.pageContext?.url || 'unknown'\n            });\n            \n            // Reset retry count on successful decision\n            this.retryCount = 0;\n            \n            // Step 4: Execute the action\n            await this.executeAction(decision, tabId);\n            \n        } catch (error) {\n            console.error('Error processing DOM observation:', error);\n            await this.handleLoopError(error);\n        }\n    }\n\n    async getAIDecisionWithRetry(domData, attempt = 1) {\n        const maxAttempts = 3;\n        \n        try {\n            return await this.getAIDecision(domData);\n        } catch (error) {\n            if (attempt < maxAttempts) {\n                await this.sendStatusUpdate(`üîÑ AI decision attempt ${attempt} failed, retrying...`, 'info');\n                await delay(1000 * attempt); // Exponential backoff\n                return await this.getAIDecisionWithRetry(domData, attempt + 1);\n            } else {\n                throw new Error(`AI decision failed after ${maxAttempts} attempts: ${error.message}`);\n            }\n        }\n    }\n\n    async getAIDecision(domData) {\n        const prompt = this.constructEnhancedPrompt(domData);\n        \n        try {\n            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${this.apiKey}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    contents: [{\n                        parts: [{ text: prompt }]\n                    }],\n                    generationConfig: {\n                        temperature: 0.1,\n                        topK: 1,\n                        topP: 0.95,\n                        maxOutputTokens: 1500,\n                        candidateCount: 1\n                    },\n                    safetySettings: [\n                        {\n                            category: 'HARM_CATEGORY_HARASSMENT',\n                            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\n                        },\n                        {\n                            category: 'HARM_CATEGORY_HATE_SPEECH',\n                            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\n                        }\n                    ]\n                })\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`Gemini API error: ${response.status} ${response.statusText} - ${errorText}`);\n            }\n\n            const data = await response.json();\n            \n            if (!data.candidates || !data.candidates[0]) {\n                throw new Error('No candidates in API response');\n            }\n            \n            const text = data.candidates[0]?.content?.parts[0]?.text;\n            \n            if (!text) {\n                throw new Error('No text content in API response');\n            }\n\n            // Enhanced JSON parsing with multiple fallback methods\n            return this.parseAIResponse(text);\n            \n        } catch (error) {\n            console.error('Gemini API error:', error);\n            throw error;\n        }\n    }\n\n    parseAIResponse(text) {\n        // Method 1: Look for JSON in code blocks\n        let jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n        \n        if (jsonMatch) {\n            try {\n                return JSON.parse(jsonMatch[1].trim());\n            } catch (e) {\n                console.warn('Failed to parse JSON from code block:', e);\n            }\n        }\n        \n        // Method 2: Look for any JSON object\n        jsonMatch = text.match(/{[\\s\\S]*}/);\n        \n        if (jsonMatch) {\n            try {\n                return JSON.parse(jsonMatch[0]);\n            } catch (e) {\n                console.warn('Failed to parse JSON object:', e);\n            }\n        }\n        \n        // Method 3: Try to extract structured information\n        const lines = text.split('\\n').filter(line => line.trim());\n        const result = { thought: '', command: '' };\n        \n        for (const line of lines) {\n            if (line.toLowerCase().includes('thought') || line.toLowerCase().includes('reasoning')) {\n                result.thought = line.replace(/.*?[:\"']\\s*/, '').replace(/[\"',]\\s*$/, '').trim();\n            }\n            if (line.toLowerCase().includes('command') || line.toLowerCase().includes('action')) {\n                const commands = ['CLICK', 'TYPE', 'SCROLL', 'WAIT', 'FINISH'];\n                const foundCommand = commands.find(cmd => line.toUpperCase().includes(cmd));\n                if (foundCommand) result.command = foundCommand;\n            }\n        }\n        \n        if (result.thought && result.command) {\n            return result;\n        }\n        \n        throw new Error('Could not parse valid JSON from AI response: ' + text.substring(0, 200));\n    }\n\n    constructEnhancedPrompt(domData) {\n        const interactiveElements = domData.elements.filter(el => el['agent-id']);\n        const contextElements = domData.elements.filter(el => el.isContext);\n        \n        const historyText = this.actionHistory.length > 0 \n            ? `\\n\\nPrevious actions taken:\\n${this.actionHistory.map((h, i) => \n                `${i + 1}. ${h.action.command}: ${h.action.thought}`\n              ).join('\\n')}` \n            : '';\n            \n        const pageInfo = domData.pageContext ? \n            `\\nPage Info:\\n- Title: ${domData.pageContext.title}\\n- URL: ${domData.pageContext.url}\\n- Has Scrollbar: ${domData.pageContext.hasScrollbar}\\n- Interactive Elements: ${interactiveElements.length}` \n            : '';\n            \n        return `You are Sparky, an expert web automation agent. You must navigate websites to achieve user goals with precision and efficiency.\n\nUSER'S GOAL: ${this.currentGoal}\n${pageInfo}\n\nINTERACTIVE ELEMENTS (use these agent-id values for targeting):\n${JSON.stringify(interactiveElements, null, 2)}\n\nPAGE CONTEXT (for understanding only):\n${JSON.stringify(contextElements, null, 2)}\n${historyText}\n\nYou MUST respond with a valid JSON object in this EXACT format:\n\n\\`\\`\\`json\n{\n  \"thought\": \"Your reasoning for this action (required, 5-200 characters)\",\n  \"command\": \"CLICK|TYPE|SCROLL|WAIT|FINISH\",\n  \"targetId\": \"agent-id-X (required for CLICK/TYPE)\",\n  \"text\": \"text to type (required for TYPE command)\",\n  \"scrollDirection\": \"UP|DOWN (required for SCROLL command)\",\n  \"answer\": \"final answer to user's goal (required for FINISH command)\"\n}\n\\`\\`\\`\n\nCRITICAL RULES:\n1. ONLY use 'agent-id' values from the INTERACTIVE ELEMENTS list above\n2. Use FINISH when you have the information to answer the user's goal\n3. Be methodical - take ONE action at a time\n4. For CLICK/TYPE: targetId is REQUIRED and must exist in the interactive elements\n5. For TYPE: text field is REQUIRED\n6. For SCROLL: scrollDirection (UP/DOWN) is REQUIRED\n7. For FINISH: answer field is REQUIRED with the final result\n8. If no suitable interactive elements exist, use SCROLL to find more content\n9. Your response must be ONLY the JSON object in code blocks - no explanations\n\nRespond with ONLY the JSON object wrapped in \\`\\`\\`json code blocks.`;\n    }\n\n    validateDecision(decision) {\n        const errors = [];\n        \n        if (!decision || typeof decision !== 'object') {\n            return { valid: false, errors: ['Decision must be an object'] };\n        }\n        \n        // Required fields\n        if (!decision.thought || typeof decision.thought !== 'string' || decision.thought.length < 5) {\n            errors.push('thought must be a string with at least 5 characters');\n        }\n        \n        if (!decision.command || !['CLICK', 'TYPE', 'SCROLL', 'WAIT', 'FINISH'].includes(decision.command)) {\n            errors.push('command must be one of: CLICK, TYPE, SCROLL, WAIT, FINISH');\n        }\n        \n        return { valid: errors.length === 0, errors };\n    }\n\n    validateCommandRequirements(decision) {\n        switch (decision.command) {\n            case 'CLICK':\n            case 'TYPE':\n                if (!decision.targetId || !decision.targetId.startsWith('agent-id-')) {\n                    return false;\n                }\n                if (decision.command === 'TYPE' && (!decision.text || typeof decision.text !== 'string')) {\n                    return false;\n                }\n                break;\n            case 'SCROLL':\n                if (!decision.scrollDirection || !['UP', 'DOWN'].includes(decision.scrollDirection)) {\n                    return false;\n                }\n                break;\n            case 'FINISH':\n                if (!decision.answer || typeof decision.answer !== 'string') {\n                    return false;\n                }\n                break;\n        }\n        return true;\n    }\n\n    async executeAction(decision, tabId) {\n        try {\n            const actionMessage = {\n                type: 'EXECUTE_ACTION',\n                payload: decision\n            };\n\n            await this.sendActionUpdate(`${decision.command}: ${decision.thought}`);\n            \n            // Send action to content script with timeout\n            const executePromise = chrome.tabs.sendMessage(tabId, actionMessage);\n            const timeoutPromise = new Promise((_, reject) => \n                setTimeout(() => reject(new Error('Action execution timeout')), 15000)\n            );\n            \n            await Promise.race([executePromise, timeoutPromise]);\n            \n        } catch (error) {\n            console.error('Error executing action:', error);\n            throw new Error(`Failed to execute action: ${error.message}`);\n        }\n    }\n\n    async handleActionCompleted(payload) {\n        await this.sendStatusUpdate(`‚úÖ ${payload.message || 'Action completed successfully'}`, 'success');\n        \n        // Continue the agentic loop after a short delay\n        await delay(1200);\n        \n        if (this.state === 'running' && this.actionHistory.length < this.maxActions) {\n            await this.runAgenticLoop();\n        }\n    }\n\n    async handleActionError(payload) {\n        await this.sendStatusUpdate(`‚ùå Action failed: ${payload.error}`, 'error');\n        \n        // Increment retry count and try again\n        await this.handleLoopError(new Error(payload.error));\n    }\n\n    async finishTask(answer) {\n        this.state = 'finished';\n        await chrome.runtime.sendMessage({\n            type: 'AGENT_FINISHED',\n            payload: { \n                answer,\n                actionsCount: this.actionHistory.length,\n                duration: this.actionHistory.length > 0 ? \n                    Date.now() - this.actionHistory[0].timestamp : 0\n            }\n        });\n    }\n\n    async sendStatusUpdate(status, level = 'info') {\n        await chrome.runtime.sendMessage({\n            type: 'AGENT_STATUS_UPDATE',\n            payload: { status, level }\n        });\n    }\n\n    async sendActionUpdate(action) {\n        await chrome.runtime.sendMessage({\n            type: 'AGENT_ACTION',\n            payload: { action }\n        });\n    }\n\n    async sendError(error) {\n        this.state = 'idle';\n        await chrome.runtime.sendMessage({\n            type: 'AGENT_ERROR',\n            payload: { error }\n        });\n    }\n}\n\n// Initialize the agent when the service worker starts\nconst sparkyAgent = new SparkyAgent();\n\n// Handle extension installation\nchrome.runtime.onInstalled.addListener(async (details) => {\n    if (details.reason === 'install') {\n        console.log('üêï Sparky AI Browser installed successfully!');\n        \n        // Open side panel on installation\n        const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (activeTab) {\n            await chrome.sidePanel.open({ tabId: activeTab.id });\n        }\n    }\n});\n\n// Handle service worker lifecycle\nself.addEventListener('message', (event) => {\n    if (event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    }\n});